匆匆忙忙的蚂蚁金服一面，第一次面试实在是紧张，很多知识点都没能答完整，也不想找别的理由，就是自己太差了，面试结果很已经很明显了，gg...
慢慢成长吧，这都是必经之路！
2月底，抱着试试看的态度，把简历发给了在阿里的老乡师兄。师兄很热心，因为他就是去年实习直接转正，所以给我讲了一共五面，每面大概会问些什么。
3月1日内推系统开放，当天下午就收到完善简历和测评的内推邮件。在此想说一下简历结尾的那三个开放性问题，如果有精力就认真写写，个人是花了一个多小时完整地回答了那三个问题（毕竟个人擅长胡煽乱谝）。
可能有幸接到面试电话和这个也有一点点关系吧。编程测评是那个四分片的题，无奈个人水平实在有限，没有完成编程测评的题目，写了几行代码就草草提交了。之后想了想那道题，也和很多大神交换了一下思路，勉强能解决出来。
3月7日下午三点，手机静音错过了杭州的电话，还担心他不会再打来了。3月10号上午11点接到电话，说是蚂蚁金服的，能否进行一个电话面试。当时在上课，所以约到下午。吃完午饭就在一直等啊等啊，结果一直到晚上7点电话才打过来。
人生第一次面试，话筒那边又是top3公司的顶级程序员，实在是太紧张了，一开始话都说的不顺溜......以下是具体问题和个人的回答及解析

1.做一个两到三分钟的自我介绍。结果我一分钟就说完了，还是有点太急了。

2.从下往上说一下OSI七个分层？ 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。

3.TCP、UDP属于哪个层？  传输   
  FTP在哪个层？  应用

OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。
五层协议（5层）：物理层、数据链路层、网络层、运输层、 应用层。
每一层的协议如下：
物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器，网关）
数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）
网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）
传输层：TCP、UDP、SPX
会话层：NFS、SQL、NETBIOS、RPC
表示层：JPEG、MPEG、ASII
应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS

每一层的作用：
物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
数据链路层：将比特组装成帧和点到点的传递（帧Frame）
网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
会话层：建立、管理和终止会话（会话协议数据单元SPDU）
表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
应用层：允许访问OSI环境的手段（应用协议数据单元APDU）

2.TCP和UDP的区别？
-TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。（TCP发出去还会问候核实一下以确保安全; UDP发出去就不管了 ）
-TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。
-TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。

TCP对应的协议:
（1） FTP：定义了文件传输协议，使用21端口。
（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。
（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。
UDP对应的协议：
（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在端口69上使用UDP服务。      


3.说说数据库连接（join）？    
回答了inner join和outer join，又说了left join与right join和区别，然后他又问我那inner join呢？
（当时直接卡壳了，一脸懵逼，无奈放弃回答，后来想想也真是好笑....）

Inner join--产生的是AB两个集合的交集   
left[outer]join--产生A的完全集，而B中匹配的则有值，没有匹配的则返回null
right[outer]join--产生B的完全集，而A中匹配的则有值，没有匹配的则返回null


4.说说事务？
脑子还在想上一道题，感觉应该很简单啊，但是死活想不起来。回答了事务四个性质，四个隔离界别，不是很完整，感觉从这块开始，心就有点急了....

(1)所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。
   *Atomicity（原子性）原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。
   *Consistency（一致性）一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。
   *Isolation（隔离性）多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
   这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。
   事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。
   *Durability（持久性）持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。
(2)标准SQL规范中定义了4个事务隔离级别，不同隔离级别对事务处理不同 。
   *未提交读（Read Uncommitted）最低的隔离级别。允许脏读(dirty reads)，但不允许更新丢失，事务可以看到其他事务“尚未提交”的修改。
   *提交读（Read Committed）允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。
    读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。
   *可重复读（Repeatable Read）禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过“共享读锁”和“排他写锁”实现。
    读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。
   *可序列化(Serializable)最高的隔离级别，它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，
    必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。
    
    隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。
(3)在MySQL中使用START TRANSACTION 或 BEGIN开启事务，提交事务使用COMMIT，ROLLBACK用来放弃事务。MySQL默认设置了事务的自动提交，即一条SQL语句就是一个事务。
总结：
事务的（ACID）特性是由关系数据库管理系统（RDBMS，数据库系统）来实现的。数据库管理系统采用日志来保证事务的原子性、一致性和持久性。
日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。
数据库管理系统采用锁机制来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许持有锁的事务能更新该数据，其他事务必须等待，
直到前一个事务释放了锁，其他事务才有机会更新该数据。

5.了解数据结构吗？单向链表概念及特点        
（突然抛出什么是链表？有点惊讶，这问题也问得有点简单了吧？难道有什么坑？）  
回答：链表就是带着指针的结构体，含数据域和指向下一个节点的地址。  
又问头部和尾部有什么特点？  
答：头部没有前驱节点，尾部指向NULL？？增删快于数组，遍历慢于数组？？...   因为面试官从头到尾都是一个语调，所以答得完整不完整并没有感觉到...... 
ps:其实链表大家都用过，但是如果真的问你什么是链表及特点，是否能用书面语言完整描述出来

6.HashMap原理
回答：底层是数组加链表实现的哈希表。允许null作为键，null作为值。线程不安全。
为什么用数组+链表实现？
利用拉链法解决冲突：把所有的同义词用单链表链接起来。该方法下，哈希表每个单元中存放的不再是元素本身，而是相应同义词单链表的头指针。

HashMap维护了一个Entry数组，Entry内部类有key,value，hash和next四个字段，其中next也是一个Entry类型。
可以将Entry数组理解为一个个的散列桶。每一个桶实际上是一个单链表。当执行put操作时，会根据key的hashcode定位到相应的桶。
遍历单链表检查该key是否已经存在，如果存在，覆盖该value，反之，新建一个新的Entry，并放在单链表的头部。
当通过传递key调用get方法时，它再次使用key.hashCode()来找到相应的散列桶，然后使用key.equals()方法找出单链表中正确的Entry，然后返回它的值。 

HashMap：线程不同步。根据key的hashcode进行存储，内部使用静态内部类Node的数组进行存储，默认初始大小为16，每次扩大一倍。当发生Hash冲突时，采用拉链法（链表）。
可以接受为null的键值(key)和值(value)。JDK 1.8中：当单个桶中元素个数大于等于8时，链表实现改为红黑树实现；当元素个数小于6时，变回链表实现。由此来防止hashCode攻击。


7.说一本印象深刻的书？回答《深入理解Java虚拟机》
 
 Java运行时数据区域？ 
回答：包括程序计数器、JVM栈、本地方法栈、方法区、堆    

8.方法区里存放什么？
当时只想到常量和静态变量...然后觉得不妥，赶紧补充：由于程序计数器、JVM栈、本地方法栈3个区域随线程而生随线程而灭，对这几个区域内存的回收和分配具有确定性。
而方法区和堆则不一样，程序需要在运行时才知道创建哪些对象，对这部分内存的分配是动态的，GC关注的也就是这部分内存。
  
  本地方法栈：和jvm栈所发挥的作用类似，区别是jvm栈为jvm执行java方法（字节码）服务，而本地方法栈为jvm使用的native方法服务。
  JVM栈：局部变量表、操作数栈、动态链接、方法出口。
  方法区：用于存储已被虚拟机加载的类信息，常量、静态变量、即时编译器编译后的代码等。
  堆：存放对象实例。

 
9.怎样判断是否需要收集？
  回答：-引用计数法：对象没有任何引用与之关联(无法解决循环引用)
        -可达性分析法：通过一组称为GC Root的对象为起点,从这些节点向下搜索，如果某对象不能从这些根对象的一个(至少一个)所到达,则判定该对象应当回收。

10.什么可作为GCRoot的对象？
回答：虚拟机栈中引用的对象。方法区中类静态属性引用的对象，方法区中类常量引用的对象，本地方法栈中JNI引用的对象。

总结：JVM这块是由自己读过的书本引出，总的来说，也算是整个面试环节里答得最好的模块了，因为这一周也的确用心准备了这块的知识点。所以大家一定要着重复习JVM这块的知识。
  
11.红黑树数据结构？  
看见别人的面经里都是问B+树，所以看了一下午B+树，反而红黑树没怎么着重准备。只回答了红黑树的五个性质。本质是二叉搜索树，左节点小于根节点，右节点大于根节点。    
看看具体具体答案，又是没回答完整.....

红黑树本质上是一颗二叉搜索树，它满足二叉搜索树的基本性质——即树中的任何节点的值大于它的左子节点，且小于它的右子节点。
一颗红黑树必须满足以下几点条件：
规则1、根节点必须是黑色。
规则2、任意从根到叶子的路径不包含连续的红色节点。
规则3、任意从根到叶子的路径的黑色节点总数相同。
作为红黑树节点，其基本属性有：节点的颜色、左子节点指针、右子节点指针、父节点指针、节点的值。
这些约束确保了红黑树的关键特性：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。
因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限 允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。
在很多树数据结构的表示中，一个节点有可能只有一个子节点，而叶子节点包含数据。用这种范例表示红黑树是可能的，但是这会改变一些性质并使算法复杂。
为此，本文中我们使用"nil叶子"或"空（null）叶子"，如上图所示，它不包含数据而只充当树在此结束的指示。这些节点在绘图中经常被省略，导致了这些树好像同上述原则相矛盾，而实际上不是这样。
与此有关的结论是所有节点都有两个子节点，尽管其中的一个或两个可能是空叶子。
因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。
然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量（O(log n)）的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。
虽然插入和删除很复杂，但操作时间仍可以保持为O(log n)次

12.Spring IOC/AOP？  
回答了IOC/DI、AOP的概念。
AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。
OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。
也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。
对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，
在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。

依赖注入(Dependency Injection)和控制反转(Inversion of Control)是同一个概念。
当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例。
但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者 实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。
不管是依赖注入，还是控制反转，都说明Spring采用动态、灵活的方式来管理各种对象。对象与对象之间的具体实现互相透明。
在理解依赖注入之前，看如下这个问题在各种社会形态里如何解决:一个人(Java实例，调用者)需要一把斧子(Java实例，被调用者)。

13.自己在应用中写过什么切面？  
这块答得不是很好....

AOP使用场景： 
Authentication 权限
Caching 缓存
Context passing 内容传递
Error handling 错误处理
Lazy loading　懒加载
Debugging　　调试
logging, tracing, profiling and monitoring　记录跟踪　优化　校准
Performance optimization　性能优化
Persistence　　持久化
Resource pooling　资源池
Synchronization　同步
Transactions 事务


14.学习编程的方法、渠道？（看博客，网站）？上哪些网站？
github、StackOverflow、CSDN

15.看过GitHub上的开放源码、项目吗（比如阿里，腾讯团队的）？
讲了讲druid。

总结：
接近30多钟，人生第一次面试，一开始紧张的话都说不顺，心里能明白某个概念，但是就是用纸面语言说不出来....如果要打分的话，个人给自己打5分，不及格！！！
回答问题时，太急了，没有条理，讲出来的答案漏洞百出。什么都知道又什么都说不全，诚然紧张真的有很大影响，但是更说明自己对这些知识点没有完全消化和理解，不能清清楚楚的表述自己的观点和看法。
有几个问题，着急得甚至差点想用方言砸出去。个人观点，用通俗的语言和例子帮助自己去加深理解一些知识点平时用很好，但是讲述时还是用书面语言吧，
能更系统、更准确，这样在回答问题的时候就会有清晰的主线，有条不紊地讲出来。

面试快结束时我对面试官表示特别感谢，很荣幸能得到这个面试机会。投了那么多简历，也只有阿里、完美世界给我回了电话。虽然嘴上说这重在参与重在参与，
但是真的有一个千载难逢的面试机会砸过来就被这样“糟蹋”，真的能不心痛吗？那可是阿里啊....
面试官真的很nice，现在看来，这次面试已经很宽容了，那些问题在别人大神看来简直都上不了台面，而我却还答得磕磕绊绊....最后一个问题，我问了他对我的看法，个人怎样提升.
面试官给了很详细的建议和指导,真的很感谢！

就把这个当成一个全新的开始，虽然这个开始并不怎么样。但对我来说，属于自己的经历不管怎么烂都是最珍贵的。在失败面前迫使自己去成长，去进步。
不断地学习和总结经验，同时锻炼的自己的语言表达和概括能力，增强自己的软实力。勉励下自己：

长这么大什么世面没见过，阿里的面试官不知道高到哪里去了，我和他谈笑风生......
  
  
  
KEEP MOVING!!!
