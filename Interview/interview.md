### 	类继承是实现继承，接口继承是功能继承
### 	Redis持久化方案
 https://my.oschina.net/davehe/blog/174662
### 	Lock和synchronized区别
a)	Reentrantlock拥有synchronized并发性和内存语义，还多了锁等候、中断锁等候
使用synchronized，如果A不释放锁，B将一直等待
使用Reentrantlock，如果A不释放，可以使B在等待足够长的时间后，中断等等，从而去干别的事
b)	Reentrantlock获取锁的三种方式
i.	Lock() 获取锁后立即返回，如果别的线程持有锁，当前线程将一直处于休眠，直到获取锁。
ii.	tryLock() 获取锁后立即返回true，如果别的线程持有锁，将抛出异常
iii.	tryLock(long timeout , TimeUnit unit ) 获取锁后立即返回true，如果别的线程持有锁，会等待参数给定的时间，如果获取到，返回true，如果等待超时，返回false。
iv.	lockInterruptibly() 如果获取到锁立即返回，如果没有获取，就会一直休眠，或者锁定，或者被别的线程中断。
c)	synchronized实在jvm层面上实现，可通过一些监控工具监控synchronized的锁定，在代码执行时出现异常，jvm会自动释放锁，但是Lock()不行，lock是通过代码实现，要保证锁一定被释放，必须将unLock()放到finally中。
d)	竞争很激烈的情况下，synchronized性能会下降几千倍，但是Reentrantlock保持常态。竞争不激烈情况下，synchronized性能优于Reentrantlock。
### 	Collection集合类中只能在Iterator中删除元素的原因？
a)	此类的 iterator 和 listIterator 方法返回的迭代器是快速失败的：在创建迭代器之后，除非通过迭代器自身的 remove 或 add 方法从结构上对列表进行修改，否则在任何时间以任何方式对列表进行修改，迭代器都会抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。
注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。

b)	在内部类Itr中，有一个字段expectedModCount ，初始化时等于modCount，即当我们调用list.iterator()返回迭代器时，该字段被初始化为等于modCount。在类Itr中next/remove方法都有调用checkForComodification()方法，在该方法中检测modCount == expectedModCount，如果不相当则抛出异常ConcurrentModificationException。

### Mysql 存储引擎类别以及差别
a)	Myisam：是旧版本MySQL的默认引擎，现在默认引擎是InnoDB。MyISAM引擎的主要特点就是快，没有事务处理操作，也不支持外键操作。适合于多读取插入，少更新删除的操作表。存储数据分成三个文件：.frm(存储表定义) .MYD(存储数据)  .MYI(存储索引)。
b)	Innodb：是新版本mysql的默认引擎，支持事务处理和外键，但是其缺点几就是慢了些。存储方式分为两种：1.共享表空间存储。[.frm(表结构) 和 innodb_data_home(数据)和innodb_data_file_path(索引)]   2.多表空间存储。 [.frm(表结构) 和 .idb（数据）  ]。
### 给出一颗二叉树，两个叶节点，找到这两个叶节点互连通的一条最短路径。（个人认为主要是找两个叶节点的最近公共祖先）
### 手写ArrayList
### 手写进制转换算法，求出一个数的二进制数1的个数
### 设计模式、spring类加载方式、实例保存在哪、aop ioc、反射机制
### 类加载器，双亲委派模型，热部署
### jvm内存模型，内存结构、堆的分代算法、堆的分区、gc算法、gc过程。
12.	 tcp ip 七层模型、rest接口规范、get和post区别，长度，安全。
13.	tcp ip的arp协议，两个同一网络的主机如何获得对方的mac地址。
14.	负载均衡、高并发、高可用的架构
15.	项目中的数据库备份，主从数据库、集群
16.	数据库的索引原理，b+树原理，trie树引申，二叉查找树的原理
17.	java的抽象类和接口区别、java的hashmap，java的内存模型，分区，分代垃圾回收算法。实例、常量放在哪里。
18.	 多线程中的wait和sleep区别，notify的作用
19.	设计模式了解哪些，写一个观察者模式。实现两个接口，一个是主题一个是观察者，并写出对应方法。
20.	写一个生产者消费者队列的方法，分别写两个类代表生产者和消费者，并且用队列模拟其生产消费。用while循环和wait notify可以实现，但我忘记在队列上加synchronize关键字，于是让我再写一题。写的是：输入一个字符串，输入第一个只出现一次的字符，写出来了。
21.	tcp ip的四次挥手，子网掩码的作用
a)	子网掩码(subnet mask)又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。
22.	了解linux么，说一下linux的内核锁？
23.	为什么要用数据库连接池，有什么好处？
对于一个简单的数据库应用，由于对于数据库的访问不是很频繁。这时可以简单地在需要访问数据库时，就新创建一个连接，用完后就关闭它，这样做也不会带来什么明显的性能上的开销。但是对于一个复杂的数据库应用，情况就完全不同了。频繁的建立、关闭连接，会极大的减低系统的性能，因为对于连接的使用成了系统性能的瓶颈。 
    连接复用。通过建立一个数据库连接池以及一套连接使用管理策略，使得一个数据库连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。
数据库连接池的基本原理是在内部对象池中维护一定数量的数据库连接，优势是：
1．	资源重用 
2．	更快的系统响应速度
3．	统一的连接管理，避免数据库连接泄漏
4．	新的资源分配手段·
24.	 java的内存模型，变量和实例存在哪。java栈的作用，java的堆存什么，方法区存什么。
25.	进程与线程
a)	http://www.cnblogs.com/losing-1216/p/5083097.html
26.	java的分代回收。
27.	内存调优的时候要更多地使用JDK提供的内存查看工具，比如JConsole和Java VisualVM。
28.	对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数，过多的GC和Full GC是会占用很多的系统资源（主要是CPU），影响系统的吞吐量。特别要关注Full GC，因为它会对整个堆进行整理，导致Full GC一般由于以下几种情况：

29.	tomcat的配置，堆得初始大小是多少，达不知道。
30.	http的数据包格式
31.	tcp包含ip么
32.	请说一下打开www.baidu.com这个网站，所有过程；
33.	socket通信过程，accept()函数是什么；
34.	锁是什么，死锁是什么一回事
35.	epoll，select听说过吗
36.	Mybatis # 和 $
a)	#{} 默认会用引号将参数引起来
i.	之前的写法，select * from product_tree_v pv where pv.product_code in(#{product}),预编译出来的结果：select * from product_tree_v pv where pv.product_code in ？；
ii.	#{}被当作一个占位符了，而参数前后也会被加上引号
b)	${} 单纯替代
i.	换成${}：select * from product_tree_v pv where pv.product_code in($product});
ii.	预编译出来的结果 ：select * from product_tree_v pv where pv.product_code in (‘p001','p002','p003');
c)	使用${}的场景：
i.	作为in条件时
ii.	参数为int类型并且数据库中字段的类型是number
iii.	表名
iv.	order by ${}，排序字段
d)	最好是能用#{}则用它，因为它可以防止sql注入，且是预编译的，在需要原样输出时才使用${}
37.	堆是由程序员自己分配和管理的，栈是由系统分配的，通常用于函数中。
38.	C，来说一下memcpy的缺陷是啥
a)	memcpy的缺陷在于，复制过程中，有可能因为字符串过长，目标地址正好指向源地址字符串的某个位置上，那么当复制到这个位置上的字符时，会造成数据修改，也就是此时的数据已经不是原来的那个数据了。
39.	有一个有序数列，从中间某个位置截成两段，将后面一段拼到前面去，找出最大数？
a)	借鉴二分查找的思想。首先取中间数，再取中间左边一个数和右边一个数，如果这个中间数比左右两边都大，那么它就是最大数；否则，如果左边数<中间数<右边数，那么取右边的那段序列，重复二分查找再取中间数；如果左边数>中间数>右边数，那么取左边那段序列，重复二分查找取中间数。
40.	你对MySQL了解吧，那你说说怎么样提高数据库的搜索效率？
41.	Volatile变量作用
a)	其他线程对变量的修改，可即时反应到当前线程中
b)	确保当前线程对volatile变量的修改可即时写到共享内存中，并对其他线程可见
c)	使用volatile的变量，编译器会保证其有序性
42.	进程间通信有哪几种方式？（我说了管道、共享内存、信号量等）说一下管道的原理是什么？线程的通信方式是什么？
a)	首先，说到管道，就是一个进程的输出作为另一个进程的输入。面试官又问，为什么这样做呢？这样做有什么好处？我当时回答的是防止第三个进行对输出数据进行篡改。面试官不太满意。我后来在网上查了一下，网上大部分对管道的解释也是很表面，管道其实是一个文件，输出进程和输入进程都是对同一个文件进行操作，保证操作连续性。后来面试官还问了共享内存的原理是什么？就是进程与进程间访问同一块内存。详情可以百度一下。最后好像还问到了锁的问题，不同的锁机制是不一样的。还有关于共享打印机的问题。这些问题我回答的时候比较混乱。也忘了当时说了些什么了。
### 说一下HTTP的两种方法？有什么区别？
a)	get和post方法。两者的区别就是地址栏里，利用get获得的参数会显示在地址栏，post则不会。post传输的数据量更加大一些。后来面试官出了一个题目，大概意思是说地址栏中的参数值是1，而表单里面的参数值是2，分别用get和post提交，提交后的参数值是多少？
### 说一下Session和Cookie的区别？现在主流的服务器使用的是哪个？
a)	get和post方法。两者的区别就是地址栏里，利用get获得的参数会显示在地址栏，post则不会。post传输的数据量更加大一些。后来面试官出了一个题目，大概意思是说地址栏中的参数值是1，而表单里面的参数值是2，分别用get和post提交，提交后的参数值是多少？
### 链表和数组的区别
a)	数组静态分配内存，链表动态分配内存
b)	数组在内存中连续，链表不连续
c)	数组元素在栈区，链表元素在堆区
d)	数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)
e)	数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)
### 红黑树对比二叉查找树BST和自平衡二叉查找树AVL
红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的算法能够做到一步旋转之内达到平衡，但红黑树能够给我们一个比较“便宜”的解决方案。
相比于BST，因为红黑树可以能确保树的最长路径不大于两倍的最短路径的长度，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证O(logN)的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到O(N)。
红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是O(logN)，所以红黑树应用还是高于AVL树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据.如果你的数据分布较好,则比较宜于采用 AVL树(例如随机产生系列数),但是如果你想处理比较杂乱的情况,则红黑树是比较快的。
### 红黑树详解
a)	http://blog.csdn.net/eson_15/article/details/51144079
48.	Spring ioc
a)	http://blog.csdn.net/qq_27093465/article/details/52547290
49.	Java 8 新特性详解
a)	http://blog.csdn.net/yczz/article/details/50896975
b)	Lambda表达式和函数式接口
c)	接口的默认方法和静态方法
i.	默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要
d)	方法引用
i.	方法引用使得开发者可以直接引用现存的方法、Java类的构造方法或者实例对象
e)	重复注解
f)	更好的类型推荐
### Tcp/ip分层及协议
a)	TCP/IP: 
数据链路层：ARP,RARP 
网络层： IP,ICMP,IGMP 
传输层：TCP ,UDP,UGP 
应用层：Telnet,FTP,SMTP,SNMP.
b)	网络接口层 这是TCP/IP软件的最低层，负责接收IP数据报并通过网络发送之，或者从网络上接收物理帧，抽出IP数据报，交给IP层。 

网间网层 负责相邻计算机之间的通信。其功能包括三方面。一、处理来自传输层的分组发送请求，收到请求后，将分组装入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口。二、处理输入数据报：首先检查其合法性，然后进行寻径——假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。三、处理路径、流控、拥塞等问题。 

传输层 提供应用程序间的通信。其功能包括：一、格式化信息流；二、提供可靠传输。为实现后者，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送。 

应用层 向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等。远程登录TELNET使用TELNET协议提供在网络其它主机上注册的接口。TELNET会话提供了基于字符的虚拟终端。文件传输访问FTP使用FTP协议来提供网络内机器间的文件拷贝功能
c)	OSI七层
i.	
### 产生死锁的四个必要条件：
（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
### Socket 和 http
a)	http：HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。
i.	HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”
ii.	由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。
b)	创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接.通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态.
53.	异常
Throwable类是异常层级中的基类。Error类表示内部错误，这类错误使我们无法控制的；Exception表示异常，RuntimeException及其子类属于未检查异常，这类异常包括ArrayIndexOutOfBoundsException、NullPointerException等，我们应该通过条件判断等方式语句避免未检查异常的发生。IOException及其子类属于已检查异常，编译器会检查我们是否为所有可能抛出的已检查异常提供了异常处理器，若没有则会报错。对于未检查异常，我们无需捕获（当然Java也允许我们捕获，但我们应该做的事避免未检查异常的发生）。

54.	For和foreach
a)	如果只是遍历集合或者数组，用foreach好些，快些。
2.如果对集合中的值进行修改，就要用for循环了。其实foreach的内部原理其实也是Iterator,但它不能像Iterator一样可以人为的控制，而且也不能调用iterator.remove()；更不能使用下标来访问每个元素，所以不能用于增加，删除等复杂的操作
55.	类加载的五个过程：加载、验证、准备、解析、初始化
56.	双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。
57.	线程同步机制（voliate,synchronized,重入锁，threadlocal），线程间通信（wait,notify）
58.	一致性哈希、RPC原理和设计（通信协议、序列化方式、超时机制等）、负载均衡、分布式缓存架构设计、分布式消息、分布式事务、paxos（这个可能只有在技术专业型很强的职位上会去问）
59.	Minor GC与Full GC分别在什么时候发生？
60.	电脑上访问一个网页，整个过程是怎么样的：DNS、HTTP、TCP、OSPF、IP、ARP。
61.	求1~n所有不能被素数相加得到的偶数
62.	最长重复子串
63.	找出数组中第一个出现2次的数
64.	重写concurrentHashMap?
65.	
66.	一面 
67.	1.死锁如何预防，解除 
68.	2.OSI 7层协议有哪些？TCP,UDP在哪一层？区别是什么？应用例子？数据链路层的作用是什么？ 
69.	3.connect是否阻塞的？select和epoll区别？ 
70.	4.算法：求一个字符串最长不重复子串，讲思路 
71.	5.算法：用两个队列实现一个栈，写伪代码 
72.	6.算法：两个升序排列的数组a,b，求两个数组里第n,n+1大元素（比O(N)更好的算法） 
73.	7.算法：非递归实现二叉树的前序遍历，手写代码 
74.	
75.	二面： 
76.	1.线程锁有哪些 
79.	3.数据库的引擎你知道哪些，区别是什么 

81.	5.手写代码：实现atoi()，其中可能是10进制，也可能是16进制。16进制以0x开头。注意判断各种边界和非法输入，有异常处理即可 
82.	6.算法：判断一棵树是否平衡二叉树，手写代码

