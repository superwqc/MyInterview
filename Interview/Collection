java.util中共有13个类可用于管理集合对象，它们支持集、列表或映射等集合
集：
    HashSet： 使用HashMap的一个集的实现。虽然集定义成无序，但必须存在某种方法能相当高效地找到一个对象。使用一个HashMap对象实现集的存储和检索操作是在固定时间内实现的.
    TreeSet： 在集中以升序对对象排序的集的实现。这意味着从一个TreeSet对象获得第一个迭代器将按升序提供对象。TreeSet类使用了一个TreeMap.
列表：
    Vector： 实现一个类似数组一样的表，自动增加容量来容纳你所需的元素。使用下标存储和检索对象就象在一个标准的数组中一样。你也可以用一个迭代器从一个Vector中检索对象。
    Vector是唯一的同步容器类??当两个或多个线程同时访问时也是性能良好的。
    Stsck: 这个类从Vector派生而来，并且增加了方法实现栈??一种后进先出的存储结构。
    LinkedList: 实现一个链表。由这个类定义的链表也可以像栈或队列一样被使用。
    ArrayList: 实现一个数组，它的规模可变并且能像链表一样被访问。它提供的功能类似Vector类但不同步。
映射：
    HashTable： 实现一个映象，所有的键必须非空。为了能高效的工作，定义键的类必须实现hashcode()方法和equal()方法。
                这个类是前面java实现的一个继承，并且通常能在实现映象的其他类中更好的使用。
    HashMap： 实现一个映象，允许存储空对象，而且允许键是空（由于键必须是唯一的，当然只能有一个）。
    WeakHashMap： 实现这样一个映象：通常如果一个键对一个对象而言不再被引用，键/对象对将被舍弃。
                这与HashMap形成对照，映象中的键维持键/对象对的生命周期，尽管使用映象的程序不再有对键的引用，并且因此不能检索对象。
    TreeMap： 实现这样一个映象，对象是按键升序排列的。
    Set和List都是由公共接口Collection扩展而来，所以它们都可以使用一个类型为Collection的变量来引用。这就意味着任何列表或集构成的集合都可以用这种方式引用，
              只有映射类除外（但也不是完全排除在外，因为可以从映射获得一个列表。）所以说，把一个列表或集传递给方法的标准途径是使用Collection类型的参数。
